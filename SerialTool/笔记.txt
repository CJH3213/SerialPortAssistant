1.	在.pro中添加QT+=serialport后，报错模块serialport无法导入，
	打开QT Maintance Tool工具，在添加组件中搜索serial，发现我现在用的
	Qt 6.7.1版本没这个组件，Qt 6.7.2有。于是取消勾选6.7.1，再对应勾选上
	6.7.2的相应组件和serial port组件，点击下一步后，就会自动卸载6.7.1再
	安装6.7.2。这时候在.pro中添加QT+=serialport就不报错了。

https://stackoverflow.com/questions/77236112/unknown-modules-in-qt-serialport


2.	设置基础Widget跟随窗口缩放，在ui设计页面，右侧对象中点击基础的Widget，
	默认它显示“分拆布局”，右键布局改为水平/垂直布局即可。


3.	先通过release生成一个exe，将这个exe拷贝出一个文件夹下，
	打开Qt 6.7.2(MinGW)黑窗软件，cd切换到文件夹路径下，
	输入命令：windeployqt 软件名.exe，自动将所需依赖复制到该文件夹下，
	这个文件夹可以带到别的电脑，直接运行。


4.交换TableWidget两行的内容：
	设row1、row2分别是两个要交换行的索引。

	如果只是交换每个格QTableWidgetItem，用以下代码即可：
    for(int col=0; col<ui->tableWidget->columnCount(); ++col)
    {
        auto item1 =ui->tableWidget->takeItem(row1, col);
        auto item2 =ui->tableWidget->takeItem(row2, col);
        ui->tableWidget->setItem(row1, col, item2);
        ui->tableWidget->setItem(row2, col, item1);
    }

	但是对于每格的CellWidget，就“不能”通过以下代码实现：
    for(int col=0; col<ui->tableWidget->columnCount(); ++col)
    {
        auto widget1 =ui->tableWidget->cellWidget(row1, col);
        auto widget2 =ui->tableWidget->cellWidget(row2, col);
        ui->tableWidget->removeCellWidget(row1, col);
        ui->tableWidget->removeCellWidget(row2, col);
        ui->tableWidget->setCellWidget(row1, col, widget2);
        ui->tableWidget->setCellWidget(row2, col, widget1);
    }
	这是因为，当控件通过setCellWidget()添加到表格后，该控件就变为只读，不允许再从表格中读取
	该控件对象出来作它用，上面错误示范会导致交换两行后表格空白，且全屏会导致软件闪退。
	其中，removeCellWidget()是将控件从表格中移除，但是控件对象并没有析构，需要手动析构，
	setCellWidget()会将该格原来的控件析构，再添加新控件到表格。

	正确的做法是应该将每格内的控件内容读出来，再构建一个新的相同控件，
	下面以CellWidget为QLineEdit作例子，主要是保证文本框文字不变：
    QString itemName1 = qobject_cast<QLineEdit*>(ui->tableWidget->cellWidget(row1, 0))->text();
    QString itemName2 = qobject_cast<QLineEdit*>(ui->tableWidget->cellWidget(row2, 0))->text();
    ui->tableWidget->setCellWidget(row1, 0, new QLineEdit(itemName2));
    ui->tableWidget->setCellWidget(row2, 0, new QLineEdit(itemName1));

https://cloud.tencent.com/developer/ask/sof/114381273
https://forum.qt.io/topic/61590/take-a-widget-from-a-qtablewidget/4

mrjj MrJJ先生 写于2015年12月11日 03:09
Hi 你好
当您使用 setCellWidget 时，QTableWidget 将拥有该控件。
阅读文档，似乎没有办法收回所有权
cellWidget（） 只允许访问它，而不是收回它，可以这么说。

因此，一种方法是创建可以根据需要创建控件的函数，并且
当您想将它们“交换”为
你不能真正制作这样的副本。

因此，您可以制作一个函数，该函数需要控件并复制一些数据
从中，并使用这些数据创建一个新的数据
或者，如果未提供控件，则使用默认值创建一个新控件。
